# 모든 개발자를 위한 HTTP 웹 기본 지식

22/07/25
인터넷에서 컴퓨터는 어떻게 통신할까?
- IP(internet protocol)패킷을 통해 출발지IP주소와 목적지IP와 메세지를 통해 전달.
- IP패킷을 받은 서버단도 마찬가지로 클라이언트 단에게 IP패킷을 보낸다.

IP프로토콜의 한계
- 비연결성(패킷을 받을 대상이 없거나 서비스 불능상태여도 패킷전송)
- 비신뢰성(중간에 패킷이 사라지거나, 패킷이 순서대로 오지않음)
- 프로그램 구분(같은IP를 사용하는 서버에서 통신하는 어플리케이션이 둘 이상)

TCP 전송제어프로토콜(Transmission Control Protocol)
- 위의 비신뢰성을 해결하기위해 등장
- TCP패킷에는 출발지PORT 목적지PORT 전송제어, 순서, 검증정보 등이 들어있다.

TCP특징 3가지
- 연결지향 (3way handshake)
- 데이터 전달 보증
- 순서 보장

22/07/26
 HTTP
- Hyper Text Transfer Protocol. 인터넷에서 데이터를 주고받을수 있는 프로토콜.
- html,text,이미지,영상,파일,json,xml등 거의 모든 형태의 데이터를 http에 실어서 전송가능.

 Stateful, Stateless
- stateful은 상태유지. 서버가 클라이언트의 상태를 보존
- stateless는 무상태. 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다. (스케일 아웃)

 Stateless의 한계 및 특징
- 로그인 처럼 로그인 했다는 상태를 서버에 유지해야 하는경우
- 상태유지는 최소한으로 사용해야 한다.

 비 연결성
- HTTP는 기본이 연결을 유지 하지 않는다.
- 클라이언트에서 request요청이 있을때에만 연결을 하므로 서버 자원을 매우 효율적으로 사용할수 있다.
- 매번 TCP/IP연결을 새로 맺어야 하는 단점.(3way Handshake시간)
- 현재는 HTTP지속연결(Persistent Connections)

 Http헤더
- Http전송에 필요한 모든 부가정보가 들어가 있다.
- 메세지 바디의 내용, 메세지 바디의크기, 인증, 요청 클라이언트 정보, 서버애플리케이션 정보 등등

 Http메세지 바디
- 실제 전송할 데이터.
- HTML문서, 이미지, 영상, Json등 byte로 표현할 수 있는 모든 데이터 전송 가능.

 Http메서드 종류
- GET : 리소스 조회
  서버에 전달하고 싶은 데이터는 쿼리스트링을 통해 전달
- POST : 요청 데이터 처리. 주로 등록에 사용
  메세지 바디를 통해 서버로 요청 데이터 전달. 서버는 요청 데이터를 처리
- PUT : 리소스를 대체. 해당 리소스가 없으면 생성
- PATCH : 리소스 부분 변경
- DELETE : 리소스 삭제

22/07/27
 클라이언트에서 서버로 데이터 전송은 크게 2가지.
- 쿼리 파라티머를 통한 데이터 전송.
  GET 주로 정렬필터(검색어)
- 메세지 바디를 통한 데이터 전송
  POST,PUT,PATCH 예)회원가입, 상품주문, 리소스 등록, 변경 등
  
 HTML Form 데이터 전송
- HTML Form 데이터 전송은 get,post만 지원.
- 전송시 웹 브라우저가 form태그를 읽어 get방식일경우 쿼리파라미터로,  
  post방식일경우 message body에 실어 보낸다.
  
 HTTP API 데이터 전송
- HTML form을 거치치 않고 데이터를 전송하는 경우 HTTP API 데이터 전송이라고함
  ex) 서버to서버, 앱 클라이언트, 웹 클라이언트(ajax, react, vuejs같은 웹 클라이언트와 API통신), Json
  
22/07/30
HTTP API 설계시 POST 기반 - 컬렉션(Collection)
- 서버가 관리하는 리소스 디렉토리
- 서버가 리소스의 URI를 생성하고 관리

 PUT 기반 - 스토어(Store) - 거의 사용하지 않음.
- 클라이언트가 관리하는 리소스 저장소
- 클라이언트가 리소스의 URI를 알고 관리

 컨트롤URI
- 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
- URI에 동사를 직접 사용.

 HTTP 상태코드
- 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능.
- 2xx(Successful): 요청 정상 처리.
- 200 OK 요청 성공
- 201 Created 요청 성공해서 새로운 리소스가 생성됨.
  생성된 리소스는 응답의 Location 헤더 필드로 식별 
- 204 No Content 서버가 요청을 성공적으로 수행했지만, 응답 페이지로드 본문에 보낼 데이터가 없음
  ex)save버튼의 결과로 아무 내용이 없어도 된다.
  
- 3xx(Redirection): 요청을 완료하려면 추가 행동이 필요
  ex)예전에 존재하던 url에 접근시 300상태코드 및 헤더에 리다이렉션 주소를 실어보내, 클라이언트를 바뀐 url로 보낸다.
- PRG: Post/Redirect/Get 일시적인 리다이렉션
  ex) 주문후 새로고침. URL이 이미 Post -> Get으로 리다이렉트됨. 새로고침해도 GET으로 결과 화면만 조회
  
- 4xx(Client Error): 클라이언트 오류. 잘못된 문법등으로 서버가 요청을 수행할 수 없음.
  클라이언트가 이미 잘못된 요청,데이터를 보내고 있기 때문에 똑같은 재시도가 실패함.
  
- 5xx(Server Error): 서버 오류. 서버가 정상 요청을 처리하지 못함.
  재시도 하면 성공할수 있음(복구되거나 등등)
  
 리다이렉  션 이해
- 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동.(리다이렉트)

22/07/31
 HTTP 헤더
- HTTP 전송에 필요한 모든 부가정보. 
  ex) 메세지 바디의 내용, 압축, 인증, 요청클라이언트, 서버정보, 캐시 등등
- General헤더 : 메세지 전체에 적용되는 정보. ex)Connection: close
- Request 헤더: 요청정보 ex)User-Agent: Mozila..
- Response헤더: 응답정보. ex)Server: Apache
- Entity헤더: 엔티티 바디정보 ex)Content-Type:text/html,json, 바디의 길이정보
  엔티티 -> 표현.(요청이나 응답에서 전달할 실제 데이터)
  
 협상(컨텐츠 네고시에이션)
- 클라이언트가 선호하는 표현 용청(미디어타입, 문자인코딩, 압축인코딩, 자연언어)
- 협상 헤더는 요청시에만 사용

 일반정보
- Referer: 현재 요청된 페이지의 이전 웹 페이지 주소. 
  A -> B로 이동하는 경우 B를 요청할 때 Referer:A를 포함해서 요청. 유입경로 분석가능
- User-Agent: 유저에이전트 애플리케이션 정보
  클라이언트의 애플리케이션 정보(웹 브라우저 정보 등등)
  통계정보. 어떤종류의 브라우저에서 장애가 발생했는지 파악가능
- Server: 요청을 처리하는 ORIGIN서버의 소프트웨어정보
  Server: Apache/2.2.22, nginx. ORIGIN서버란, 중간의 서버가 아닌 실제 요청을 처리하는 마지막서버단. 응답에서 사용
- *Host: 요청한 호스트 정보(도메인)
  요청에서 사용. 필수헤더. 하나의 서버가 여러 도메인을 처리해야할때
- Location: 페이지 리다이렉션.
- 인증: Authoriztion 클라이언트 인증 정보를 서버에 전달 
- 쿠키
  Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
  응답을 받은 브라우저의 쿠키 저장소에 Set-Cookie저장
  서버에서 쿠키를 클라이언트로 보낼때, 서버측은 세션id를 만들어 해당 클라이언트의 정보를 저장해놓고 그 key를 셋 쿠키에 보낸다. 
  클라이언트는 그 세션id를 서버요청시마다 보낸다. 쿠키의 정보는 항상 서버에 전송된다.
  쿠키에는 도메인정보 와 만료정보가 포함되어있다.
  Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, 이후 HTTP요청시 모든 요청에 쿠키 정보를 서버로 전달
  
 Stateless. (한번더 정리)
- HTTP는 무상태(Stateless)프로토콜이다.
- 클라리언트와 서버가 요청과 응답을 주고받으면 연결이 끊어진다
- 클라이언트가 다시 요청하면 서버는 이전요청을 기억하지 못한다
- 클라이언트와 서버는 서로 상태를 유지하지 않는다

 캐시
- 캐시가 없을경우, 데이터가 변경되지 않아도 계속 네트워크를 통해 데이터를 다운로드 받아야 하므로 브라우저 로딩속도가 느리다
- 캐시적용ex)cache-control: max-age=60
  브라우저 캐시 저장소에 위의 헤더정보를 저장.
  두번째요청에 위를 먼저 뒤져 정보가 있다면, 캐시에서 조회하여 네트워클 사용하지 않는다.
- 검증헤더와 조건부 요청. (ETag도 있다)
  캐시 유효시간이 만료되면 매번 서버에 다시 요청하나?
  단. 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요(검증헤더)
- 검증헤더: Last-Modified: 날짜
- 조건부요청 헤더:if-modified-since: 날짜
  위의 두 헤더정보로, 아래 두 경우를 판별하여, 기존 데이터가 변경되지 않을경우 304(바디정보x)상태값을 보내어, 다시 브라우저 캐시 저장소에서 찾게 한다
  1) 서버에서 기존데이터를 변경
  2) 서버에서 기존 데이터를 변경X
 
 프록시캐시
- 프록시는 클라이언트와 서버 사이 중간을 거쳐서 통신 수행. 그 중계 기능을 하는 서버를 프록시 서버라고 한다.

 캐시 무효화
- ex)통장잔고는 실시간으로 바뀌어야 하므로 캐시되면 안된다. 헤더에 아래의 정보를 넣어줘야 한다.
- Cache-Control: no-cache
  데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용
- Cache-Control: no-store
  데이터에 민감한 정보가 있으므로 저장하면 안됨
- Cache-Control: must-revalidate
  캐시 만료후 최초 조회시 원 서버에 검증해야함
- Pragma: no-cache
  HTTP 1.0 하위 호환